public class synchPermSetsWithGroupMem {
    
    //	Gregory Woods June 2016
    
    public static void queryAndUpdatePSAsOnTheUserRecord() {
        
        //		BUILD LIST OF PS THAT ARE COUPLED TO GROUPMEMBERSHIP BY BUILDING A MAP OF 
        //		NOT ONLY DO WE NEED IT LATER TO ASSIGN USERS TO GROUPS (REMOVE), BUT... 

        map <string, string> psandgroupids = new map <string, string>();
        
        map <String, permissionSetsWithGroups__c> mcs = permissionSetsWithGroups__c.getAll();
        
		map <string, string> gpsidsreverseindex = new map <string, string>();        


 
        //	THIS LOOP CREATES TWO MAPS ONE MAPS PERMISSION SETS TO GROUPS
        //	AND THE OTHER IS A REVERSE INDEX THAT MAPS GROUPS TO PERMISSION SET
        //	THIS ACCOUNTS FOR THE POSSIBILITY THAT MANY PERMISSION SETS MAY MAP TO A SINGLE GROUP...
        //	HOWEVER, IT DOES NOT ADDRESS THE (ALSO) DISTINCT POSSIBILITY THAT A SINGLE PERMISSION SET MIGHT
        //	MAP TO MORE THAN ONE GROUP...
        //			and...
        //			I SUSPECT WILL BE TO REPEAT THE EXTENDED STRING PROCESS AS DEMO'D W EXTENDVAL'S USE
        //			IN THE IF CLAUSE BELOW...

        for (string r : mcs.keyset()) {
            
            
            //	WRITE SAME CURL AS FOR REVERSEINDEX
            
            psandgroupids.put(mcs.get(r).permissionSetId__c, mcs.get(r).groupId__c);
            
            
            system.debug(r + ' : ' + mcs.get(r).permissionSetId__c);
            
            if (gpsidsreverseindex.keyset().contains(mcs.get(r).groupId__c)) {
                string extendval = gpsidsreverseindex.get(mcs.get(r).groupId__c) + ',' + mcs.get(r).permissionSetId__c;
                gpsidsreverseindex.put(mcs.get(r).groupId__c, extendval);
            }
            
            else {
                gpsidsreverseindex.put(mcs.get(r).groupId__c, mcs.get(r).permissionSetId__c);
            }
            
            
        }
        
        system.debug('comp1 : ' + psandgroupids);
        system.debug('comp1 : ' + gpsidsreverseindex);
        
        
        for (string k : psandgroupids.keyset()) {

                //	LISTIFICATION HERE BECAUSE GET(K) RETURNS A STRING CONTAINING SEVERAL IDS..
            
            string groupid = psandgroupids.get(k);
            
            system.assertequals(true, gpsidsreverseindex.keyset().contains(groupid));
           
            
        }
        

        //	NOW WE CAN MODIFY A QUERY ON PERMISSION SET ASSIGNMENTS TO INCLUDE ONLY THOSE WHERE THE permissionSetId
        //	IN : psandgroupIds.keyset();
        
        //	ON A FIRST RUN,  (OR ANY RUN, FOR THAT MATTER)  THIS QUERY WILL PULL ALL NEW PSA RECORDS, 
        //	IRRESPECITVE OF WHETHER THEY ARE NEW OR NO
        
     list <permissionSetAssignment> psas = [SELECT id, assigneeId, permissionSetId, systemModStamp FROM permissionSetAssignment 
                                            WHERE permissionSetId IN : psandgroupids.keyset() 
                                            ORDER BY assigneeId, systemModStamp ASC];
           
        system.debug('synchPermSets... : ' + psas);
        
        //	THUSLY, WE ARE NOT TRACKING A BUNCH OF STUFF WE DO NOT CARE ABOUT  - 
        //	I.E. - PERMISSION SETS NOT COUPLED TO GROUP MEMBERSHIPS.. WE DON'T CARE ABOUT THOSE...
        
        string lastuserinloop = '';
        string userrecordinloop = '';
        
        string psids = '';
        
        map <string, string> newuserwith = new map <string, string>();
        map <string, string> olduserwith = new map <string, string>();
        

        
        for (permissionSetAssignment p : psas) {
            
            userrecordinloop = string.valueof(p.assigneeid);
            
            if (string.isblank(lastuserinloop)) {
                
                lastuserinloop = userrecordinloop;
                
            }
            
            
            
            if (userrecordinloop != lastuserinloop )  {	// THIS IS A NEW USER RECORD IN THE LOOP, SO..
                
                //	PUT USER ID AND PSIDS INTO A NEWMAP ( THIS REPRESENTS LOCAL DATA STATE UPON EXIT F/PREVIOUS ITERATION)
                //	CLEAR OUT VALS AND START AGAIN
                
                newuserwith.put(lastuserinloop, psids);
                
                psids = '';
                lastuserinloop = userrecordinloop;
            }
                        
            psids += p.permissionSetId + ',';      
            

        }
        
        newuserwith.put(userrecordinloop, psids);  //	ADDS THE LAST RECORD AND PSID TO THE MAP (I.E. !HASNEXT)


        
        system.debug('comp2 : ' + newuserwith);
        
        
		//		THIS LOOP THROUGH USER BUILDS TWO LISTS OF BEFORE AND AFTER VALS OF PERMISSION SET ASSIGNMENTS
		//		FOR LATER COMPARISON IN DETAIL
		//		BECAUSE, IN ALL CASES SAVE CASE ONE, NEWUSERWITH REPRESENTS THE CURRENT STATE OF PSET ASSIGNMENTS,
		//		THEN THIS IS THE VALUE THAT GET PUT INTO THE USER RECORD; IT WILL BE ASSIGNED TO THE LIST NOW...

        list <user> userupdates = new list <user>();
        
        for (user u : [SELECT id, psids__c FROM user]) {
            
            if (!string.isblank(u.psids__c)) {
                system.debug('synchPermSets... : ' + u.id + ' : ' + u.psids__c);
                
            }
            
            if (string.isblank(u.psids__c) && !newuserwith.keyset().contains(u.id)){
                continue;
            }
            
            else if (!string.isblank(u.psids__c) && !newuserwith.keyset().contains(u.id)) {
                olduserwith.put(u.id, u.psids__c);
                newuserwith.put(u.id, '');
                userupdates.add(new user(id = u.id, psids__c =''));
            }
            
            else if (string.isblank(u.psids__c) && newuserwith.keyset().contains(u.id)) {
                olduserwith.put(u.id, '');
                userupdates.add(new user(id = u.id, psids__c = newuserwith.get(u.id)));
            }
            
            //  IS THIS SUFFICIENT? FOR MULTIPLE PERMISSION SETS... DO (HOW  ?) WE KNOW THEY ARE SAME-ORDERED?
            //	ANSWER IS...WE DON'T...  THE METHOD FOLLOWING DOES ALL THE NITTY-GRITTY ITEM BY ITEM COMPS
            
            else  {
                
                if (u.psids__c == newuserwith.get(u.id)) {  // I.E - OLD AND NEW HAVE SAME VALS
                    newuserwith.remove(u.id);
                }            
                
                else {      
                    
                    olduserwith.put(u.id, u.psids__c);
                    userupdates.add(new user(id = u.id, psids__c = newuserwith.get(u.id)));
                    
                }                
            }  
        }

        system.debug('comp3 : ' + newuserwith);
        system.debug('comp3 : ' + olduserwith);
        
        //	AT THE END OF THIS ITERABLE, WE HAVE OLDUSERWITH, WHICH IS PRIOR VALUE OF PSIDS FOR A USER THAT HAS NEW LIST OF 
        //	"WITH" RECORDS
        
        
        map <string, list <string>> addgroupm = new map <string, list <string>>();
        map <string, list <string>> deletegroupm = new map <string, list <string>>();
        
        list <string> oldpsets = new list <string>();
        
        list <string> addlist = new list <string>();
        list <string> removelist = new list <string>();
        

        string newpsetstrings = '';
        string oldpsetstrings = '';
        
        string thisuinloop = '';
        string lastuinloop = '';
        
        //	EITHER ONE, OR THE OTHER, BUT NOT BOTH... NEWUSERWITH OR OLDUSERWITH... MAY BE NULL...
        //	SO WE ARE GOING TO GUESS TO START...
        
        
        for (string user : olduserwith.keyset()) {
            
            if (string.isblank(lastuinloop)) {
                lastuinloop = user;
            }
            
            if (lastuinloop != user) {
                
                //	put the assembled list in their respective maps
                //	clear list values // NEED TO DO THE SAME UPON EXIT WHERE THERE !HASNEXT
                
                if (!addlist.isempty()) {
                    list <string> listtoadd = new list <string>();
                    listtoadd = addlist.clone();
                    addgroupm.put(lastuinloop, listtoadd);
                    addlist.clear();
                }
                
                if (!removelist.isempty()) {
                    list <string> listtoremove = new list <string>();
                    listtoremove = removelist.clone();
                    deletegroupm.put(lastuinloop, listtoremove);
                    removelist.clear();
                }
                
            }
            
            
            
            
            if (!string.isblank(olduserwith.get(user))) {
                
                newpsetstrings = newuserwith.get(user);
                
                for (string oldps : olduserwith.get(user).split(',')) {
                    
                    if (!newpsetstrings.contains(oldps)) {
                        removelist.add(oldps);
                    }
                }
                
                if (!string.isblank(newuserwith.get(user))) {
                    
                    oldpsetstrings = olduserwith.get(user);
                    
                    for (string newps : newuserwith.get(user).split(',')) {
                        
                        if (!oldpsetstrings.contains(newps)) {
                            addlist.add(newps);
                        }
                    }
                    
                }               
 
            }
            
            else {  //	IF OLD USER HAS NO PSETIDS, THEN WE HAVE TO START THE QUERY WITH NEW USER
                	//	AND BASICALLY, WE KNOW THAT ALL PSIDS IN NEW USER WITH GET IN THE ADD LIST

                for (string newps : newuserwith.get(user).split(',')) {

                    addlist.add(newps);
  
                }

            }
            
            system.debug('comp4 : ' + addlist);
            system.debug('comp4 : ' + removelist);            
        
            lastuinloop = user;
            
        }  	//	END USER LOOP
        
        //	ADD EXIT VALS TO MAPS WHERE THERE IS NO HASNEXT
        
        system.debug('comp4 : ' + addlist);
        system.debug('comp4 : ' + removelist);    
        
        
        if (!addlist.isempty()) {
            list <string> listtoadd = new list <string>();
            listtoadd = addlist.clone();
            addgroupm.put(lastuinloop, listtoadd);
            addlist.clear();
        }
        
        if (!removelist.isempty()) {
            list <string> listtoremove = new list <string>();
            listtoremove = removelist.clone();
            deletegroupm.put(lastuinloop, listtoremove);
            removelist.clear();
        }     
        
        system.debug('comp5 : ' + addgroupm);
        system.debug('comp5 : ' + deletegroupm);
        
        
       
        
        //	OKAY, SO NOW WE HAVE AN ADD GROUP AND A DELETE GROUP... MAP OF LIST OF STRINGS KEYED TO THE USER...
        //	
        //	THE ADD LIST IS EASY, OF COURSE... SIMPLY BUILD A GROUP MEMBER RECORD WHERE THE USERORGROUPID = USERID,
        //	AND THE GROUP ID = GET GROUP ID THROUGH USER GET PERMISSION SET ID THROUGH TO PERMISSION SET ID GET GROUP ID

        map <string, set <string>> usersDeleteGroupList = new map <string, set <string>>();
        
        list <string> deletedPermissionsList = new list <string>();
        set <string> groupAssignmentsToDelete = new set <string>();
        
        for (string uw : deletegroupm.keyset()) {
            deletedPermissionsList = deletegroupm.get(uw);

                //	LISTIFICATION AND MULTIPLE ADDITIONS TO GROUPASSIGNMENTSTODELETE HERE...
            
            for (string psetid : deletedPermissionsList) {
                groupAssignmentsToDelete.add(psandgroupids.get(psetid));
            }
            
            set <string> clonegroupAssignmentstoDelete = new set <string>();
            clonegroupassignmentstodelete = groupassignmentstodelete.clone();
            usersDeleteGroupList.put(uw, clonegroupAssignmentsToDelete);
            groupAssignmentsToDelete.clear();
            
        }
        


        
        
        list <groupMember> deleteMemberships = new list <groupMember>();
        
        string lastuseringrinder = '';
        string newuseringrinder = '';
        
        for(groupMember M : [SELECT id, userorgroupid, groupid 
                             FROM groupMember WHERE userorgroupid IN : deletegroupM.keyset()
                            ORDER BY userorgroupid]) {
                                
                                newuseringrinder = string.valueof(m.UserOrGroupId);
                                
                                if (string.isblank(lastuseringrinder)) {
                                    lastuseringrinder = newuseringrinder;
                                }                                
                                
                                //	MAYBE WANT TO DO SOMETHING HERE TO PUSH QUERY FOLLOWING TO IGNORE KEYS THAT ARE NOT == M.USERORGROUPID
                                //	MAYBE... LIST <STRING> THISUSERDELETELIST = USERSDELETEGROUPLIST.GET(M.USERORGROUPID)
                                
                                for (string user : usersDeleteGroupList.keyset()) {
                                    
                                    if (m.UserOrGroupId == user && usersDeleteGroupList.get(user).contains(m.GroupId)) {
                                        
                                        //	WE CHECK THE REVERSE INDEX BECAUSE SINGLETON PAIRINGS (NO MANY-TO-ONES) 
                                        //	DO NOT REQUIRE THIS CHECKING
                                        //	WE CHECK NEWUSERWITH BECAUSE IF THE USER HAS NO PS, THEN IT STANDS TO REASON 
                                        //	THAT HE HAS ALSO NO GM, AND THEREFORE ANY HE HAS MAY BE SAFELY DELETED
                                        
                                        boolean bothhave = false;
                                        
                                        if (!gpsidsreverseindex.keyset().contains(m.groupid)) {
                                            
                                            deleteMemberships.add(new groupMember(id = m.id)); 
                                        }
                                        
                                        else {
                                            
                                            if (!newuserwith.keyset().contains(m.userorgroupid)) {
                                                deleteMemberships.add(new groupMember(id = m.id));
                                            }
                                            
                                            else  {
                                                
                                                list <string> psthatNeedThisGroup = gpsidsreverseindex.get(m.groupId).split(',');
                                                
                                                for (string ps : psthatneedthisgroup) {
                                                    
                                                    if (newuserwith.get(user).contains(ps)) {
                                                        bothhave = true;
                                                        break;
                                                    }
                                                }
 
                                            }                                                
                                                       
                                            if (!bothhave) {
                                                deleteMemberships.add(new groupMember(id = m.id));
                                            }
  
                                        } 
                                    }  
                                }

                                // AND KEEP THIS REMOVAL FOR WHEN LOOPING IS DONE
                                
                                usersDeleteGroupList.remove(m.UserOrGroupId);
                                
                                if (usersDeleteGroupList.isempty()) {
                                    break;
                                }

                             }	// END GROUP MEMBER M LOOP....
        
        
        
        list <groupMember> newMemberships = new list <groupMember>();
        
        //	THIS CONSTRUCTOR MUST ADDRESS THE POSSIBILITY THAT TWO DIFFERENT PERMISSION SET ASSIGNMENTS
        //	FOR THE USER WILL POINT TO THE SAME GROUP
        //	AND WE DO NOT WANT TO CREATE TO GROUP MEMBERSHIP RECORDS TO THE SAME GROUP...
        //	SO... INSTEAD OF ADDING GROUP MEMBER RECORDS STRAIGHT AWAY
        //	WE ARE FIRST GOING TO PUT EACH GROUP ID INTO A SET....  WHICH PREVENTS DUPLICATION
        
        set <string> groupids = new set <string>();
        
        for (string u : addgroupm.keySet()) {
            
            for (string psetid : addgroupm.get(u)) {
                
                //	LISTIFICATION AND MULTIPLE ADDITIONS TO GROUPIDS HERE...

                groupids.add(psandgroupids.get(psetid));
   
            }
            
            for (string gid : groupids) {
                
                newMemberships.add(new groupMember(userorgroupid = u, groupid = gid));
                
            }
            
            
        }
        
        //		NOW, WE HAVE NEWMEMBERSHIPS, WE HAVE DELETEMEMBERSHIP AND WE HAVE USERUPDATES
        

        system.debug('comp6 : ' + newMemberships);

        insert newMemberships;
        
        system.debug('comp6 : ' + deleteMemberships);
        
        delete deleteMemberships;
        
        system.debug(userupdates);
        
        update userupdates;
        
        


        
    }  //	END METHOD QUERY AND UPDATE PSAs ON THE USER RECORD...
    
    
    

}
